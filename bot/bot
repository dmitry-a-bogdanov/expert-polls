#!/usr/bin/env python3

import datetime
import locale
import logging
import sqlite3
from argparse import ArgumentParser, FileType
from enum import (Enum)
from functools import wraps
from typing import *

import telegram.utils
import telegram.utils.request
from telegram import *
from telegram.ext import *
from telegram.ext.dispatcher import run_async

log = logging.getLogger(__name__)

PollId = int
DMITRY_BOGDDANOV = 160453507  # type: int


class MessageId:
    def __init__(self, chat_id: int = None, message_id: int = None, inline_message_id: str = None):
        inline = inline_message_id is not None
        chat = (chat_id is not None) and (message_id is not None)
        if inline == chat:
            raise ValueError()
        self._chat_id = chat_id
        self._message_id = message_id
        self._inline_message_id = inline_message_id

    @property
    def chat_id(self) -> int:
        return self._chat_id

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def inline_message_id(self) -> str:
        return self._inline_message_id

    @property
    def is_inline(self):
        return self._inline_message_id is not None

    def __str__(self):
        return f'MessageId(chat={self._chat_id}, msg={self._message_id}, inline_message_id={self._inline_message_id})'

    __repr__ = __str__


class STATE:
    WAIT_FOR_PLACE = 0
    WAIT_FOR_DATE = 1
    WAIT_FOR_TIME = 2


class Emoji:
    BOAR = '\U0001F417'
    TOILET = '\U0001F6BD'
    PLUS = '\U00002795'
    MINUS = '\U00002796'


class OPTION(Enum):
    ME_TOO = ('me_too', f'{Emoji.PLUS}')
    ME_NOT = ('me_not', f'{Emoji.MINUS}')
    PLUS_ONE = ('plus_one', f'{Emoji.BOAR} человечек подскочит')
    MINUS_ONE = ('minus_one', f'{Emoji.TOILET} человечек слился')

    def __init__(self, option_id: str, text: str):
        self._option_id = option_id
        self._text = text

    @property
    def option_id(self):
        return self._option_id

    @property
    def text(self):
        return self._text

    @classmethod
    def from_string(cls, option_id: str):
        for opt in cls:
            if option_id == opt.option_id:
                return opt
        raise ValueError('not an option')


class VoteType:
    PRO = 1
    CONS = 2
    PLUS_ONE = 3


class Vote:
    def __init__(self, uid: int, name: str, vote_type: VoteType):
        self._uid = uid
        self._name = name
        self._vote_type = vote_type

    @property
    def username(self):
        return self._name

    def is_pro(self):
        return self._vote_type in (VoteType.PLUS_ONE, VoteType.PRO)

    def format_user(self):
        return f'[{self._name}](tg://user?id={self._uid})'

    def show(self):
        if self._vote_type == VoteType.PLUS_ONE:
            return f'+1 (от {self.format_user()})'
        else:
            return self.format_user()

    def __str__(self):
        return f'Vote({self._vote_type}, {self._uid}, {self._name})'

    __repr__ = __str__


class Poll:
    def __init__(self, text: str):
        self._text = text

    @property
    def text(self) -> str:
        return self._text


class PollExt(Poll):
    def __init__(self, poll_id: PollId, votes_pro: List[Vote], votes_cons: List[Vote], *args, **kwargs):
        super(PollExt, self).__init__(*args, **kwargs)
        self._id = poll_id
        self._votes_pro = votes_pro
        self._votes_cons = votes_cons

    @property
    def votes_pro(self) -> List[Vote]:
        return self._votes_pro

    @property
    def votes_cons(self) -> List[Vote]:
        return self._votes_cons

    @property
    def id(self) -> PollId:
        return self._id

    def __str__(self):
        return f'PollExt(id={self.id}, text={self.text}, votes_pro={self.votes_pro}, votes_cons={self.votes_cons})'

    __repr__ = __str__

    def build_text(self):
        log.info(f'Generating text for poll {self}')

        def total_str(votes: List):
            n = len(votes)
            return f'({n})' if n > 0 else ''

        text = str(self.text)
        text += '\n\n'
        text += f'`+ `{total_str(self.votes_pro)}\n'
        for prefix, vote in zip(generate_prefix(len(self.votes_pro)), self.votes_pro):
            text += '`{}` {}\n'.format(prefix, vote.show())
        text += '\n`-`\n'
        for prefix, vote in zip(generate_prefix(len(self.votes_cons)), self.votes_cons):
            text += '`{}` {}\n'.format(prefix, vote.show())
        text += '\n'
        return text

    def build_markup(self) -> InlineKeyboardMarkup:
        log.info(f'Generating markup for poll {self._id}')

        def button(opt: OPTION):
            return InlineKeyboardButton(text=opt.text, callback_data=(poll_id + ':' + opt.option_id))

        poll_id = str(self._id)
        return InlineKeyboardMarkup(inline_keyboard=[
            [button(OPTION.ME_TOO), button(OPTION.ME_NOT)],
            [button(OPTION.PLUS_ONE)], [button(OPTION.MINUS_ONE)],
            [InlineKeyboardButton(text='Share', switch_inline_query=poll_id)]
        ])


class Storage:
    def __init__(self, connection: sqlite3.Connection):
        self._data = dict()
        self._seq = 0
        self._db = connection

        self._db.executescript('''
            BEGIN TRANSACTION;
            CREATE TABLE IF NOT EXISTS polls (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                text TEXT NOT NULL
            );
            CREATE TABLE IF NOT EXISTS users (
                uid INTEGER PRIMARY KEY NOT NULL,
                name TEXT NOT NULL,
                is_admin INTEGER NOT NULL DEFAULT 0
            );
            INSERT OR REPLACE
                INTO users (uid, name, is_admin)
                VALUES (160453507, 'Dmitry Bogdanov', 1);
            CREATE TABLE IF NOT EXISTS own_votes (
                poll_id INTEGER NOT NULL REFERENCES polls (id),
                uid INTEGER NOT NULL REFERENCES users (uid),
                vote_type INTEGER NOT NULL,
                t TEXT,
                PRIMARY KEY (poll_id, uid)
            );
            CREATE TABLE IF NOT EXISTS others_votes (
                poll_id INTEGER NOT NULL REFERENCES polls (id),
                uid INTEGER NOT NULL REFERENCES users (uid),
                vote_type INTEGER NOT NULL,
                t TEXT
            );
            CREATE TABLE IF NOT EXISTS messages (
                poll_id INTEGER NOT NULL REFERENCES polls (id),
                chat_id INTEGER,
                msg_id INTEGER,
                inline_message_id INTEGER
            );
            CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER NOT NULL,
                place TEXT,
                d TIMESTAMP,
                t TIMESTAMP
            );
            CREATE TABLE IF NOT EXISTS places (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                place TEXT NOT NULL
            );
            CREATE TRIGGER IF NOT EXISTS update_own_votes_datetime
                AFTER UPDATE ON own_votes
                BEGIN
                    UPDATE own_votes SET t = strftime('%Y-%m-%d %H:%M:%f', 'now')
                    WHERE rowid = NEW.rowid and OLD.vote_type != NEW.vote_type;
                END;
            CREATE TRIGGER IF NOT EXISTS update_others_votes_datetime
                AFTER UPDATE ON others_votes
                BEGIN
                    UPDATE others_votes SET t = strftime('%Y-%m-%d %H:%M:%f', 'now') WHERE rowid = NEW.rowid;
                END;
            CREATE TRIGGER IF NOT EXISTS insert_own_votes_datetime
                AFTER INSERT ON own_votes
                BEGIN
                    UPDATE own_votes SET t = strftime('%Y-%m-%d %H:%M:%f', 'now') WHERE rowid = NEW.rowid;
                END;
            CREATE TRIGGER IF NOT EXISTS insert_others_votes_datetime
                AFTER INSERT ON others_votes
                BEGIN
                    UPDATE others_votes SET t = strftime('%Y-%m-%d %H:%M:%f', 'now') WHERE rowid = NEW.rowid;
                END;
            COMMIT TRANSACTION;
            ''')

    def insert_poll(self, poll: Poll) -> PollId:
        log.info(f'Saving poll {poll}')
        cursor = self._db.cursor()
        cursor.execute('''
            INSERT INTO polls (text) values (:text);
        ''', {'text': poll.text})
        cursor.connection.commit()
        return cursor.lastrowid

    def select_poll(self, poll_id: PollId) -> PollExt:
        log.info(f'Selecting poll with id {poll_id}')
        cursor = self._db.cursor()
        cursor.execute('SELECT text FROM polls WHERE id = :poll_id', {'poll_id': poll_id})
        text = cursor.fetchone()[0]
        votes = self.select_votes(poll_id)
        votes_pro = list(filter(lambda x: x.is_pro(), votes))
        votes_cons = list(filter(lambda x: not x.is_pro(), votes))
        return PollExt(poll_id=poll_id, votes_pro=votes_pro, votes_cons=votes_cons, text=text)

    def insert_message(self, poll: PollId, message_id: MessageId):
        log.info(f'saving message {message_id} for poll {poll}')
        self._db.execute(
            'INSERT OR REPLACE INTO messages(poll_id, chat_id, msg_id, inline_message_id) VALUES (?, ?, ?, ?)',
            [poll, message_id.chat_id, message_id.message_id, message_id.inline_message_id])
        self._db.commit()

    def select_messages(self, poll_id: PollId) -> List[MessageId]:
        log.info(f'selecting messages for poll with id {poll_id}')
        c = self._db.cursor()
        c.execute('SELECT chat_id, msg_id, inline_message_id FROM messages WHERE poll_id = :poll_id',
                  {'poll_id': poll_id})
        return list(map(lambda x: MessageId(chat_id=x[0], message_id=x[1], inline_message_id=x[2]), c.fetchall()))

    def save_user(self, uid: int, name: str):
        log.info(f'saving user {name} (uid={uid})')
        c = self._db.cursor()
        c.execute('BEGIN')
        c.execute('INSERT OR REPLACE INTO users (uid, name) VALUES (:uid, :name)', {'uid': uid, 'name': name})
        self._db.commit()

    def start_sessions(self, user: User):
        self._db.execute('INSERT OR REPLACE INTO sessions (id) VALUES (:uid)', {'uid': user.id})
        self._db.commit()

    def set_place_in_session(self, user: User, place: str):
        self._db.execute('UPDATE sessions SET place = :place WHERE id = :uid', {'place': place, 'uid': user.id})
        self._db.commit()

    def set_date_in_session(self, user: User, date: datetime.date):
        faketime = datetime.datetime.now().time()
        self._db.execute('UPDATE sessions SET d = :date WHERE id = :uid', {
            'date': datetime.datetime.combine(date, faketime),
            'uid': user.id
        })
        self._db.commit()

    def set_time_in_session(self, user: User, time: datetime.time):
        fakedate = datetime.datetime.now().date()
        self._db.execute('UPDATE sessions SET t = :time WHERE id = :uid', {
            'time': datetime.datetime.combine(fakedate, time),
            'uid': user.id
        })
        self._db.commit()

    def get_session(self, user: User) -> Tuple[str, datetime.date, datetime.time]:
        c = self._db.execute('SELECT place, d, t FROM sessions where id = :uid', {'uid': user.id})
        r = c.fetchone()
        return r[0], r[1].date(), r[2].time()

    def insert_place(self, place: str):
        self._db.execute('INSERT OR IGNORE INTO places (place) VALUES (?)', [place])
        self._db.commit()

    def select_places(self) -> Dict[int, str]:
        c = self._db.cursor()
        c.execute('SELECT id, place FROM places')
        places = {p[0]: p[1] for p in c.fetchall()}
        return places

    def remove_place(self, id: int):
        self._db.execute('REMOVE FROM places WHERE id = :id', {'id': id})
        self._db.commit()

    def vote(self, poll_id: PollId, user: User, opt: OPTION):
        uid = user.id
        self._db.execute('BEGIN TRANSACTION;')
        if opt == OPTION.ME_TOO:
            self.__insert_own_vote_in_tx(poll_id, uid, VoteType.PRO)
        elif opt == OPTION.ME_NOT:
            self.__insert_own_vote_in_tx(poll_id, uid, VoteType.CONS)
        elif opt == OPTION.PLUS_ONE:
            self._execute('''
            INSERT INTO others_votes (poll_id, uid, vote_type)
            VALUES (:poll_id, :uid, :vote_type);
            ''', poll_id=poll_id, uid=uid, vote_type=VoteType.PLUS_ONE)
        elif opt == OPTION.MINUS_ONE:
            self._execute('''
            DELETE FROM others_votes
            WHERE rowid = (SELECT MAX(rowid) FROM others_votes WHERE poll_id = :poll_id AND uid = :uid)
            ''', poll_id=poll_id, uid=uid)
        else:
            log.error(f'Unknown option: {opt}. poll: {poll_id}, user: {user}', opt, poll_id, user)
            raise ValueError('Unknown option')
        self._db.commit()

    def _execute(self, request: str, **kwargs):
        self._db.execute(request, kwargs)

    def __insert_own_vote_in_tx(self, poll_id: PollId, uid: int, vote_type: VoteType):
        self._execute('''
        INSERT OR IGNORE INTO own_votes (poll_id, uid, vote_type)
        VALUES (:poll_id, :uid, :vote_type)
        ''', poll_id=poll_id, uid=uid, vote_type=vote_type)
        self._execute('''
        UPDATE own_votes
        SET vote_type = :vote_type
        WHERE poll_id = :poll_id AND uid = :uid
        ''', poll_id=poll_id, uid=uid, vote_type=vote_type)

    def select_votes(self, poll_id: PollId) -> List[Vote]:
        c = self._db.cursor()
        c.execute('''
            SELECT vote_type, uid, name FROM (
                SELECT vote_type, users.uid as uid, name, t
                    FROM own_votes
                    JOIN users ON own_votes.uid = users.uid
                    WHERE poll_id = :poll_id
                UNION ALL
                SELECT vote_type, users.uid as uid, name, t
                    FROM others_votes
                    JOIN users ON others_votes.uid = users.uid
                    WHERE poll_id = :poll_id
            ) ORDER BY t
        ''', {'poll_id': poll_id})
        votes = []
        for row in c.fetchall():
            vote_type = row[0]
            uid = row[1]
            name = row[2]
            votes.append(Vote(uid=uid, name=name, vote_type=vote_type))
        return votes

    def upsert_user(self, user: User):
        self._execute('''
        INSERT INTO users (uid, name)
        VALUES (:uid, :name)
        ON CONFLICT(uid) DO
            UPDATE
            SET name = :name
            WHERE uid = :uid
        ''', uid=user.id, name=user.full_name)
        self._db.commit()


def actualize_users(handler):
    @wraps(handler)
    def wrapped(update: Update, context: CallbackContext):
        storage = Conf.storage()
        storage.upsert_user(update.effective_user)
        return handler(update, context)

    return wrapped


def admins_only(handler):
    @wraps(handler)
    def wrapped(update: Update, context: CallbackContext):
        user = update.effective_user  # type: User
        if user.id != DMITRY_BOGDDANOV:
            chat = update.effective_chat  # type: Chat
            context.bot.send_message(chat_id=chat.id, text='You are not my master')
            return ConversationHandler.END
        else:
            return handler(update, context)

    return wrapped


@actualize_users
@admins_only
def handle_start(update: Update, context: CallbackContext):
    log.info(f'user {update.effective_user} started conversation')
    storage = Conf.storage()

    storage.start_sessions(update.effective_user)

    places = storage.select_places()
    keyboard = [[p] for p in places.values()]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)

    update.message.reply_markdown('Что? - и так понятно. Где?', reply_markup=reply_markup)

    return STATE.WAIT_FOR_PLACE


@actualize_users
@admins_only
def handle_place(update: Update, context: CallbackContext):
    log.info(f'user {update.effective_user} sent place')
    storage = Conf.storage()
    msg = update.message  # type: Message
    place = msg.text_markdown
    storage.set_place_in_session(update.effective_user, place)

    today = datetime.date.today()
    keyboard = []  # type: List[List[str]]
    COLUMNS = 2
    ROWS = 4
    for i in range(ROWS):
        keyboard.append([])
        for j in range(COLUMNS):
            day = today + datetime.timedelta(days=COLUMNS * i + j)
            keyboard[i].append(day.strftime('%d.%m (%A)'))
    markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)

    update.message.reply_markdown('Когда?', reply_markup=markup)

    return STATE.WAIT_FOR_DATE


@actualize_users
@admins_only
def handle_date(update: Update, context: CallbackContext):
    log.info(f'user {update.effective_user} sent date')

    today = datetime.date.today()

    date_str = update.message.text  # type: str
    date_str = date_str.split(' ')[0]
    date = datetime.datetime.strptime(date_str, '%d.%m').date()
    date = date.replace(year=today.year)
    if date < today:
        date = date.replace(today.year + 1)

    storage = Conf.storage()
    storage.set_date_in_session(update.effective_user, date)

    markup = ReplyKeyboardMarkup(keyboard=[["11:00", "11:11", "19:00", "19:05"]], one_time_keyboard=True,
                                 resize_keyboard=True)

    update.message.reply_markdown('А точнее?', reply_markup=markup)

    return STATE.WAIT_FOR_TIME


@actualize_users
@admins_only
def list_places(update: Update, context: CallbackContext):
    places = Conf.storage().select_places()
    text = '\n'.join([f'{p[0]}) {p[1]}' for p in places.items()])
    update.message.reply_markdown(text)
    return ConversationHandler.END


@actualize_users
@admins_only
def remove_place(update: Update, context: CallbackContext):
    place_id = int(update.message.text)
    Conf.storage().remove_place(place_id)
    return ConversationHandler.END


@actualize_users
@admins_only
def handle_time(update: Update, context: CallbackContext):
    log.info(f'user {update.effective_user} sent time')

    time_str = update.message.text  # type: str
    time = datetime.datetime.strptime(time_str, '%H:%M').time()

    storage = Conf.storage()
    storage.set_time_in_session(update.effective_user, time)

    (place, date, time) = storage.get_session(update.effective_user)

    text = f'{date.strftime("%d %B %Y, %A")}. {time.strftime("%H:%M")}. {place}\n\nОбкашляем вопросики?'
    poll_id = storage.insert_poll(Poll(text))

    send_saved_poll(context.bot, update.message.chat.id, poll_id)

    return ConversationHandler.END


def generate_prefix(size: int):
    yielded = 0
    if yielded == size:
        return
    without_last = size - 1
    for i in range(without_last):
        yield '├'
    yield '└'
    return


def send_saved_poll(bot: Bot, chat_id: int, poll_id: PollId):
    storage = Conf.storage()
    poll = storage.select_poll(poll_id=poll_id)
    sent_message = bot.send_message(chat_id=chat_id,
                                    text=poll.build_text(),
                                    parse_mode=ParseMode.MARKDOWN,
                                    reply_markup=poll.build_markup())
    bot.send_message(chat_id=chat_id, text='Готово. Ещё? press /newpoll', reply_markup=ReplyKeyboardRemove())
    sent_message_id = MessageId(chat_id=sent_message.chat_id, message_id=sent_message.message_id)
    storage.insert_message(poll_id, sent_message_id)


@run_async
def update_poll_message(bot: Bot, poll: PollExt, msg: MessageId):
    try:
        bot.edit_message_text(chat_id=msg.chat_id,
                              message_id=msg.message_id,
                              inline_message_id=msg.inline_message_id,
                              text=poll.build_text(),
                              parse_mode=ParseMode.MARKDOWN,
                              reply_markup=poll.build_markup()
                              )
    except Exception as e:
        log.error(f'Cannot edit: {e}')


def update_poll_messages(bot: Bot, poll_id: PollId):
    storage = Conf.storage()
    messages = storage.select_messages(poll_id)
    poll = storage.select_poll(poll_id)
    for msg in messages:
        update_poll_message(bot, poll, msg)


@actualize_users
def handle_text(update: Update, context: CallbackContext):
    storage = Conf.storage()
    poll = Poll(text=update.message.text)
    poll_id = storage.insert_poll(poll)
    send_saved_poll(context.bot, update.message.chat.id, poll_id)
    return ConversationHandler.END


@actualize_users
def handle_vote(update: Update, context: CallbackContext):
    query = update.callback_query  # type: CallbackQuery

    def parse_vote_data(data: str):
        [poll_id_str, option_id] = data.split(':')
        return int(poll_id_str), OPTION.from_string(option_id)

    poll_id, option = parse_vote_data(query.data)

    log.info(f'user {update.effective_user} vote for {option} in poll {poll_id}')

    storage = Conf.storage()

    storage.vote(poll_id, update.effective_user, option)

    update_poll_messages(context.bot, poll_id)

    query.answer()


@actualize_users
def handle_inline_query(update: Update, context: CallbackContext):
    query = update.inline_query  # type: InlineQuery
    poll_id = int(query.query)
    poll_ext = Conf.storage().select_poll(poll_id)
    bot = context.bot  # type: Bot
    bot.answer_inline_query(cache_time=0,
                            inline_query_id=query.id,
                            results=[InlineQueryResultArticle(
                                id=poll_id,
                                title=poll_ext.text,
                                input_message_content=InputTextMessageContent(
                                    message_text=poll_ext.build_text(),
                                    parse_mode=ParseMode.MARKDOWN
                                ),
                                reply_markup=poll_ext.build_markup()
                            )])


@actualize_users
def handle_choosen_inline_query(update: Update, context: CallbackContext):
    query = update.chosen_inline_result  # type: ChosenInlineResult
    poll_id = int(query.query)
    message_id = MessageId(inline_message_id=query.inline_message_id)
    Conf.storage().insert_message(poll_id, message_id)


@actualize_users
@admins_only
def handle_add_place(update: Update, context: CallbackContext):
    log.info(f'Adding place: {update.message}')
    msg = update.message  # type: Message
    command = msg.entities[0]  # type: MessageEntity
    place = msg.text[(command.length + command.offset + 1):]
    Conf.storage().insert_place(place)

    return ConversationHandler.END


class Conf:
    _db = None

    @classmethod
    def init(cls, in_memory_db: bool):
        cls._db = ':memory:' if in_memory_db else 'polls.sqlite'
        Conf.storage()

    @classmethod
    def storage(cls):
        return Storage(connection=sqlite3.connect(cls._db,
                                                  detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES))


def main():
    logging.basicConfig(level=logging.DEBUG,
                        format='[%(asctime)s %(filename)s:%(lineno)d:%(funcName)s %(name)s] %(levelname)s: %(message)s')

    locale.setlocale(locale.LC_TIME, "ru_RU.UTF-8")

    parser = ArgumentParser()
    parser.add_argument('--proxy', type=str)
    token_args = parser.add_mutually_exclusive_group(required=True)
    token_args.add_argument('--token_file', type=FileType('r'))
    token_args.add_argument('--token', type=str)
    parser.add_argument('--in_memory', action='store_const', const=True, default=False)

    args = parser.parse_args()

    token = args.token_file.readline().rstrip() if args.token_file is not None else args.token

    Conf.init(args.in_memory)

    request = telegram.utils.request.Request(proxy_url=args.proxy, con_pool_size=8)

    bot = Bot(token=token, request=request)
    updater = Updater(bot=bot, use_context=True)

    dispatcher = updater.dispatcher
    dispatcher.add_handler(ConversationHandler(
        entry_points=[
            CommandHandler(['start', 'reset', 'newpoll', 'new_poll'], handle_start),
            CommandHandler(['add_place'], handle_add_place),
            CommandHandler(['list_places'], list_places)
        ],
        states={
            STATE.WAIT_FOR_PLACE: [MessageHandler(Filters.text, handle_place)],
            STATE.WAIT_FOR_DATE: [MessageHandler(Filters.text, handle_date)],
            STATE.WAIT_FOR_TIME: [MessageHandler(Filters.text, handle_time)]
        },
        fallbacks=[]
    ))
    dispatcher.add_handler(CallbackQueryHandler(
        callback=handle_vote
    ))
    dispatcher.add_handler(InlineQueryHandler(callback=handle_inline_query))
    dispatcher.add_handler(ChosenInlineResultHandler(callback=handle_choosen_inline_query))

    updater.start_polling()
    updater.idle()


if __name__ == '__main__':
    main()
